use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize, sqlx::FromRow)]
pub struct Suspect {
    pub id: i32,
    pub full_name: Option<String>,
    pub personal_id: Option<String>,
    pub flag: Option<bool>,
}

/// Struct for creating a new suspect (POST requests)
/// Excludes id as it's auto-generated by the database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CreateSuspect {
    pub full_name: String,
    pub personal_id: String, // Swedish format: YYYYMMDD-XXXX
    #[serde(default)]
    pub flag: bool,
}

/// Struct for updating an existing suspect (PUT requests)
/// All fields are optional except personal_id which identifies the suspect
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateSuspect {
    pub personal_id: String, // Required: identifies which suspect to update
    pub full_name: Option<String>,
    pub flag: Option<bool>,
}

/// Struct for partial updates (PATCH requests)
/// All fields are optional including personal_id lookup
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PatchSuspect {
    pub full_name: Option<String>,
    pub personal_id: Option<String>,
    pub flag: Option<bool>,
}

impl Suspect {
    /// Validate Swedish personal ID format (YYYYMMDD-XXXX)
    pub fn validate_personal_id(personal_id: &str) -> bool {
        if personal_id.len() != 13 {
            return false;
        }
        
        let parts: Vec<&str> = personal_id.split('-').collect();
        if parts.len() != 2 {
            return false;
        }
        
        // Check date part (YYYYMMDD)
        if parts[0].len() != 8 || !parts[0].chars().all(|c| c.is_numeric()) {
            return false;
        }
        
        // Check suffix (XXXX)
        if parts[1].len() != 4 || !parts[1].chars().all(|c| c.is_numeric()) {
            return false;
        }
        
        true
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_personal_id() {
        assert!(Suspect::validate_personal_id("19850312-2398"));
        assert!(Suspect::validate_personal_id("19900204-1457"));
        assert!(Suspect::validate_personal_id("20010122-2183"));
    }

    #[test]
    fn test_invalid_personal_id() {
        assert!(!Suspect::validate_personal_id("1985031-2398")); // Too short
        assert!(!Suspect::validate_personal_id("19850312-239")); // Suffix too short
        assert!(!Suspect::validate_personal_id("19850312+2398")); // Wrong separator
        assert!(!Suspect::validate_personal_id("198503122398")); // No separator
        assert!(!Suspect::validate_personal_id("ABCD0312-2398")); // Non-numeric date
    }
}